### Pod详解

Pod是kubernetes项目的原子调度单元

#### 1、为什么需要Pod

容器的本质是进程，kubernetes相当于操作系统

部署的应用，往往都存在着类似于“进程和进程组”的关系，这些应用之前有着密切的协作关系，使得他们必须部署在同一台机器（部署在一起）

Docker Swarm处理这种协作关系，会使用调度队列，按照先后顺序调度，如果某台节点资源不足就会造成分配到不同的节点上，就是典型的成组调度没有被妥善处理。Mesos处理这种协作关系，会有资源囤积（resource hoarding）的机制，成组资源都到达后才开始调度。Google Omega采用乐观调度处理冲突的方法，先不管冲突，而是通过精心设计的回滚机制在出现冲突后解决问题

以上方法都谈不上完美。资源囤积带来不可避免的调度效率损失和死锁的可能性；而乐观调度的复杂程度，则不是常规技术团队能驾驭的

但是在kubernetes中，这些问题迎刃而解：Pod是原子调度单位，kubernetes的调度器是统一按照Pod而非容器的资源需求来设计的，密切协作关系的容器放进一个Pod中进行调度。

像这样容器间的紧密协作，我们可以称为“超亲密关系”。这些具有“超亲密关系”容器的典型特征包括但不限于：互相之间会发生直接的文件交换、使用 localhost 或者 Socket 文件进行本地通信、会发生非常频繁的远程调用、需要共享某些 Linux Namespace（比如，一个容器要加入另一个容器的 Network Namespace）等等

在kubernetes中，Pod中多容器共享Namespace有：UTS（主机名、内核等）、PID、IPC（信号量、队列和共享内存）、User、mnt、NET。Pod实现共享Namespace是通过使用一个中间容器：Infra容器

在Pod中，Infra容器永远都是第一个被创建的容器，而其他用户定义的容器，则是通过Join的方式，与Infra容器关联在一起。Infra容器使用非常特殊的镜像（k8s.gcr.io/pause，这个镜像使用汇编语言编写的，永远处理“暂停”状态的容器，解压后大小只有100KB-200KB左右），占用很少的资源。Infra容易Hold住Network Namespace后，用户容器就可以加入到Infra容器的Network Namespace中，Pod的声明周期只跟Infra容器一致。

Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。

现在可以这么理解 Pod 的本质：Pod，实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序。所以下一次，当你需要把一个运行在虚拟机里的应用迁移到 Docker 容器中时，一定要仔细分析到底有哪些进程（组件）运行在这个虚拟机里。然后，你就可以把整个虚拟机想象成为一个 Pod，把这些进程分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。这才是更加合理的、松耦合的容器编排诀窍，也是从传统应用架构，到“微服务架构”最自然的过渡方式。

