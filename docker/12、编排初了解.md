### 编排初了解

“编排”是kubernetes最核心的功能

Pod这个看似复杂的API对象，实际上就是对容器的进一步抽象和封装。Pod是容器的升级版，它对容器进行了组合，添加了更多的属性和字段。这就好比给集装箱（Pod）四面安装了吊环，使得kubernetes这架“吊车”，可以更轻松地操作它。

#### 1、“控制器”模型

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

这个Deployment定义的编排动作很简单，定义集群中该Pod数量为2，多则删除，少则新建。执行这些操作的组件是kube-controller-manger，实际上，这个组件就是一系列控制器的组合。

这些控制器都遵循kubernetes项目中的一个通用编排模式，即：控制循环（control loop），伪代码表示

```go
X是待编排的对象
for {
  # 实际状态来自k8s集群本身
  实际状态 := 获取集群中对象 X 的实际状态（Actual State）
  # 期望状态来自用户提交的yaml文件
  期望状态 := 获取集群中对象 X 的期望状态（Desired State）
  if 实际状态 == 期望状态{
    什么都不做
  } else {
    执行编排动作，将实际状态调整为期望状态
  }
}
```

针对上面Deployment的例子，简单描述下对控制器模型的实现：

1. Deployment控制器从Etcd中获取到该Yaml文件中Pod，然后统计他们的数量，这就是实际状态
2. Deployment对象的Replicas字段就是期望状态
3. Deployment控制器将两个状态做比较，然后根据比较结果，确定是创建Pod，还是删除已有Pod

可以看到，一个kubernetes对象的主要编排逻辑，实际上是在第三步的“对比”阶段完成的，这个操作通常被叫做调谐（Reconcile），这个调谐过程，被叫"Reconcile Loop"（调谐循环）或者“Sync Loop”（同步循环），他们都指同一个东西：控制循环。

kubernetes中这种控制器设计原理，就是“用一种对象管理另一种对象”的“艺术”。其中，这个控制器对象本身，负责定义被管理对象的期望状态，比如Deployment里的replicas=2这个字段，而被控制对象的定义，则来源于一个“模板”，比如Deployment里的template字段。

可以看到Deployment这个template字段里的内容，跟一个标准Pod对象的API定义丝毫不差。而所有被这个Deployment管理的Pod实例，其实就是根据这个template字段的内容创造出来的。

这个template字段，在kubernetes项目中有专门的名字，叫做PodTemplate（Pod模板），这个概念很重要，大多数控制器，都会使用PodTemplate来统一定义它所要管理的Pod，当然还有其他类型的对象模板，比如Volume的模板。

至此，我们对Deployment以及其他类似的容器，做一个简单总结：

![](https://github.com/Feng-Xu/TechNotes/blob/master/my_image/k8s_controller.png)

如上图所示，类似Deployment这样一个控制器，实际上都是由上半部分的**控制器定义（包括期望状态）**，加上下半部分的**被控制对象的模板**组成的